浮点，floating point,精髓就在于小数点是可移动的（这也是名字的由来）

起初的规范中，只要求有效位，没能要求指数位的变化（或者说默认指数位固定），这给计算带来很大麻烦

所以再引入一个变量，来控制小数点的位置，小数点可以左右来回“浮动”，这样就是“浮点”了

关于浮点数的偏移问题，其实很简单

正常来算，首位为符号位，8位为指数位，剩下23位为有效位

（根据约定，有效位为0.xxx,实际计算表示时加1,即保证均为科学记数法，类似于$1.5\times 2^{32}$的形式，所以只保存0.5和32）


| 组成部分 | 位宽 (bit) | 位位置 (从高到低) | 名称与说明 |
| :--- | :--- | :--- | :--- |
| **符号位 (Sign)** | **1** | 31 | `S`: `0`表示正数，`1`表示负数 |
| **指数位 (Exponent)** | **8** | 30 - 23 | `E`: 采用**偏移码**表示，偏置值 = **127** |
| **尾数位 (Mantissa)** | **23** | 22 - 0 | `M`: 有效数字的小数部分 (隐含整数位) |

（这里暂不考虑诸如NaN的特殊情况）

例如，有效位存储为

位4 3 2 1 0

值1 1 1 0 0

就是表示$0\times 2^{-23} + 0 \times 2^{-22} + 1 \times 2^{-21}\cdots$

但是这会带来一个问题：+0和-0的出现，即除符号位外均为0

最初目的只有一个：让浮点数“看起来”像整数，也就是在仅仅知道符号位和长度的情况下，依然能做基础的操作（例如比较大小），这样就可以在老爷爷机子（没有专门的浮点运算处理单元）上跑了

然后，指数位为什么不直接按整数补码存呢？其实纯粹是为了增加比较的速度，不用解补码（浮点数的相关运算要尽可能快，因为本来就慢....）

为了让他看起来像整数，我们想的是符号范围也是这么变化，即在表示的时候从0000-1111时，实际值经历从+0 ---- +MAX ---- -0 ---- -MAX的变化

所以引入偏移量这个东西，保证了这一性质

说白了，旧时代的残党，我们只要记住就行（

然后，引入bias以后，考虑一下x/0的情形，这是无穷大，我们需要有位置存下这个无穷大

假设x是一个32位浮点，由于bias要减127,所以能表示的最大有限数为

指数位11111110，尾数位全为1，最大有限再加1就是无限大（没别的，就是单纯保留无穷大和0这一块，所以不用过度纠结）

于是，当指数位为全1时，尾数位非零时，我们用来表示各种NaN(not a number)，比如0/0,sqrt(-4)之类可以充分利用，用来设置错误码

真是太美妙了！！！


